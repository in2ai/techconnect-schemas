"""
Export SQL DDL schema for different database dialects.

Similar to `drizzle-kit export`, this generates CREATE TABLE statements
without connecting to an actual database.

Usage:
    python export_schema.py --dialect postgres
    python export_schema.py --dialect mysql
    python export_schema.py --dialect sqlite
    python export_schema.py --dialect postgres --output schema.sql
"""

import argparse
from sqlalchemy import create_engine
from sqlalchemy.schema import CreateTable
from sqlalchemy.dialects import postgresql, mysql, sqlite

from sqlmodel import SQLModel

# Import all models to register them with SQLModel metadata
from models import (
    Patient,
    Tumor,
    LiquidBiopsy,
    Biomodel,
    Passage,
    Trial,
    PDXTrial,
    PDOTrial,
    LCTrial,
    Implant,
    SizeRecord,
    Mouse,
    FACS,
    UsageRecord,
    Image,
    Cryopreservation,
    GenomicSequencing,
    MolecularData,
)


# Dialect mapping
DIALECTS = {
    "postgres": postgresql.dialect(),
    "postgresql": postgresql.dialect(),
    "mysql": mysql.dialect(),
    "sqlite": sqlite.dialect(),
}


def get_create_table_sql(table, dialect) -> str:
    """Generate CREATE TABLE SQL for a single table."""
    return str(CreateTable(table).compile(dialect=dialect))


def export_schema(dialect_name: str) -> str:
    """
    Export the complete schema as SQL DDL statements.
    
    Args:
        dialect_name: Database dialect ('postgres', 'mysql', 'sqlite')
        
    Returns:
        Complete SQL schema as a string
    """
    if dialect_name not in DIALECTS:
        raise ValueError(f"Unknown dialect: {dialect_name}. Choose from: {list(DIALECTS.keys())}")
    
    dialect = DIALECTS[dialect_name]
    
    # Get all tables in dependency order
    metadata = SQLModel.metadata
    
    # Generate header
    lines = [
        "-- TechConnect Database Schema",
        f"-- Dialect: {dialect_name}",
        "-- Generated by export_schema.py",
        "--",
        "-- This file was auto-generated from SQLModel definitions.",
        "-- Do not edit directly.",
        "",
    ]
    
    # Generate CREATE TABLE statements in correct order (respecting foreign keys)
    for table in metadata.sorted_tables:
        sql = get_create_table_sql(table, dialect)
        # Clean up and format
        sql = sql.strip()
        if not sql.endswith(";"):
            sql += ";"
        lines.append(sql)
        lines.append("")
    
    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(
        description="Export SQL DDL schema for different database dialects"
    )
    parser.add_argument(
        "--dialect", "-d",
        choices=["postgres", "postgresql", "mysql", "sqlite"],
        default="postgres",
        help="Database dialect (default: postgres)"
    )
    parser.add_argument(
        "--output", "-o",
        type=str,
        default=None,
        help="Output file path (default: print to stdout)"
    )
    
    args = parser.parse_args()
    
    schema_sql = export_schema(args.dialect)
    
    if args.output:
        with open(args.output, "w", encoding="utf-8") as f:
            f.write(schema_sql)
        print(f"âœ… Schema exported to {args.output}")
    else:
        print(schema_sql)


if __name__ == "__main__":
    main()
